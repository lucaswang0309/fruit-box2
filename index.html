<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>水果箱大賽</title>
    <style>
        body { 
            text-align: center; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            background: #fdf5e6; margin: 0; padding: 0; overflow: hidden; touch-action: none; 
        }
        #game-container {
            width: 100vw; height: 100vh;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .stats { 
            display: flex; justify-content: space-around; align-items: center;
            width: 98vw; font-size: 16px; margin-bottom: 10px; color: #5d4037; font-weight: bold; min-height: 40px; 
        }
        canvas { 
            background: white; border: 3px solid #8b4513; border-radius: 8px;
            max-width: 95vw; max-height: 80vh; touch-action: none; display: block;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        .btn-group { display: flex; gap: 8px; }
        .ui-btn {
            color: white; border: none; padding: 6px 12px;
            border-radius: 5px; font-weight: bold; cursor: pointer; font-size: 13px;
        }
        #pause-trigger { background: #8b4513; }
        #restart-trigger { background: #d32f2f; }
    </style>
</head>
<body>
    <div id="game-container">
        <div class="stats" id="stats-bar" style="visibility: hidden;">
            <div>分數: <span id="score">0</span></div>
            <div>時間: <span id="timer">120</span></div>
            <div class="btn-group">
                <button class="ui-btn" id="pause-trigger">暫停</button>
                <button class="ui-btn" id="restart-trigger">重新開始</button>
            </div>
        </div>
        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const timerEl = document.getElementById('timer');
        const statsBar = document.getElementById('stats-bar');
        const pauseBtn = document.getElementById('pause-trigger');
        const restartBtn = document.getElementById('restart-trigger');
        
        const COLS = 17, ROWS = 10, CELL_SIZE = 50;
        canvas.width = COLS * CELL_SIZE;
        canvas.height = ROWS * CELL_SIZE;

        let gameState = 'start'; 
        let grid = [], score = 0, timeLeft = 120;
        let isDragging = false, startX, startY, currentX, currentY;
        let timerInterval;
        let highScore = localStorage.getItem('fruitBoxHighScore') || 0;

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        function playSound(type) {
            try {
                if (audioCtx.state === 'suspended') audioCtx.resume();
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain); gain.connect(audioCtx.destination);
                const now = audioCtx.currentTime;
                if (type === 'success') {
                    osc.frequency.setValueAtTime(800, now);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    osc.start(); osc.stop(now + 0.2);
                }
            } catch(e) {}
        }

        // 回到開始畫面
        function showStartScreen() {
            gameState = 'start';
            statsBar.style.visibility = 'hidden';
            if(timerInterval) clearInterval(timerInterval); // 確保回到主頁時計時器完全停止
            highScore = localStorage.getItem('fruitBoxHighScore') || 0;
            draw();
        }

        function startGame() {
            gameState = 'playing';
            statsBar.style.visibility = 'visible';
            pauseBtn.innerText = "暫停";
            score = 0; timeLeft = 120;
            scoreEl.innerText = score;
            timerEl.innerText = timeLeft;

            for (let r = 0; r < ROWS; r++) {
                grid[r] = [];
                for (let c = 0; c < COLS; c++) {
                    grid[r][c] = { val: Math.floor(Math.random() * 9) + 1, cleared: false };
                }
            }

            if(timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (gameState === 'playing') {
                    if(timeLeft > 0) {
                        timeLeft--;
                        timerEl.innerText = timeLeft;
                    } else {
                        endGame();
                    }
                    draw();
                }
            }, 1000);
            draw();
        }

        function togglePause() {
            if (gameState === 'playing') {
                gameState = 'paused';
                pauseBtn.innerText = "繼續";
            } else if (gameState === 'paused') {
                gameState = 'playing';
                pauseBtn.innerText = "暫停";
            }
            draw();
        }

        // 修改：點擊重新開始時回到主選單
        function manualRestart() {
            const confirmRestart = confirm("確定要放棄本局並回到主選單嗎？");
            if (confirmRestart) {
                showStartScreen();
            }
        }

        function endGame() {
            gameState = 'gameover';
            clearInterval(timerInterval);
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('fruitBoxHighScore', highScore);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameState === 'start') {
                drawStartUI();
            } else {
                drawGrid();
                if (isDragging && gameState === 'playing') drawSelection();
                if (gameState === 'paused') drawPauseUI();
                if (gameState === 'gameover') drawResultUI();
            }
        }

        function drawStartUI() {
            ctx.fillStyle = "#fffae6";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.textAlign = "center";
            ctx.fillStyle = "#d32f2f";
            ctx.font = "bold 64px sans-serif";
            ctx.fillText("水果箱大賽", canvas.width/2, 160);
            ctx.fillStyle = "#5d4037";
            ctx.font = "22px sans-serif";
            ctx.fillText("數字總和等於 10 即可消除", canvas.width/2, 230);
            ctx.fillStyle = "#e67e22";
            ctx.font = "bold 32px sans-serif";
            ctx.fillText("最高紀錄: " + highScore, canvas.width/2, 300);
            ctx.fillStyle = "#43a047";
            ctx.fillRect(canvas.width/2 - 100, 360, 200, 60);
            ctx.fillStyle = "white";
            ctx.font = "bold 28px sans-serif";
            ctx.fillText("開始遊戲", canvas.width/2, 400);
        }

        function drawGrid() {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (!grid[r][c].cleared) {
                        ctx.fillStyle = "#ff4d4d"; ctx.beginPath();
                        ctx.arc(c * CELL_SIZE + 25, r * CELL_SIZE + 25, 18, 0, Math.PI * 2); ctx.fill();
                        if (gameState !== 'paused') {
                            ctx.fillStyle = "white"; ctx.font = "bold 20px Arial"; ctx.textAlign = "center";
                            ctx.fillText(grid[r][c].val, c * CELL_SIZE + 25, r * CELL_SIZE + 32);
                        }
                    }
                }
            }
        }

        function drawPauseUI() {
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "white";
            ctx.font = "bold 48px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("暫停中", canvas.width/2, canvas.height/2);
            ctx.font = "20px sans-serif";
            ctx.fillText("點擊按鈕繼續遊戲", canvas.width/2, canvas.height/2 + 50);
        }

        function drawSelection() {
            let sum = calculateSum();
            ctx.strokeStyle = (sum === 10) ? "#4caf50" : "#2196f3";
            ctx.lineWidth = 3; 
            ctx.strokeRect(startX, startY, currentX - startX, currentY - startY);
            ctx.fillStyle = (sum === 10) ? "rgba(76,175,80,0.2)" : "rgba(33,150,243,0.1)";
            ctx.fillRect(startX, startY, currentX - startX, currentY - startY);
        }

        function drawResultUI() {
            ctx.fillStyle = "rgba(0,0,0,0.8)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "white";
            ctx.fillRect(canvas.width/2 - 160, 100, 320, 280);
            ctx.fillStyle = "#333";
            ctx.font = "bold 32px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("遊戲結束", canvas.width/2, 160);
            ctx.font = "24px sans-serif";
            ctx.fillText("本次得分: " + score, canvas.width/2, 210);
            ctx.fillStyle = "#e67e22";
            ctx.fillText("最高紀錄: " + highScore, canvas.width/2, 250);
            ctx.fillStyle = "#43a047";
            ctx.fillRect(canvas.width/2 - 80, 290, 160, 50);
            ctx.fillStyle = "white";
            ctx.font = "bold 22px sans-serif";
            ctx.fillText("回主選單", canvas.width/2, 323);
        }

        function calculateSum() {
            let x1 = Math.min(startX, currentX), x2 = Math.max(startX, currentX);
            let y1 = Math.min(startY, currentY), y2 = Math.max(startY, currentY);
            let sum = 0;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    let cx = c * CELL_SIZE + 25, cy = r * CELL_SIZE + 25;
                    if (!grid[r][c].cleared && cx > x1 && cx < x2 && cy > y1 && cy < y2) sum += grid[r][c].val;
                }
            }
            return sum;
        }

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
        }

        function handleStart(e) {
            const pos = getPos(e);
            if (gameState === 'start') {
                if (pos.x > canvas.width/2 - 100 && pos.x < canvas.width/2 + 100 &&
                    pos.y > 360 && pos.y < 420) {
                    startGame();
                }
            } else if (gameState === 'gameover') {
                if (pos.x > canvas.width/2 - 80 && pos.x < canvas.width/2 + 80 &&
                    pos.y > 290 && pos.y < 340) {
                    showStartScreen();
                }
            } else if (gameState === 'playing') {
                isDragging = true;
                startX = pos.x; startY = pos.y;
                currentX = pos.x; currentY = pos.y;
            }
        }

        function handleMove(e) {
            if (!isDragging || gameState !== 'playing') return;
            const pos = getPos(e);
            currentX = pos.x; currentY = pos.y;
            draw();
        }

        function handleEnd() {
            if (!isDragging) return;
            isDragging = false;
            if (gameState !== 'playing') return;
            
            let x1 = Math.min(startX, currentX), x2 = Math.max(startX, currentX);
            let y1 = Math.min(startY, currentY), y2 = Math.max(startY, currentY);
            let selected = [], sum = 0;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    let cx = c * CELL_SIZE + 25, cy = r * CELL_SIZE + 25;
                    if (!grid[r][c].cleared && cx > x1 && cx < x2 && cy > y1 && cy < y2) {
                        selected.push({r, c}); sum += grid[r][c].val;
                    }
                }
            }
            if (sum === 10) {
                selected.forEach(p => grid[p.r][p.c].cleared = true);
                score += selected.length; scoreEl.innerText = score; playSound('success');
            }
            draw();
        }

        pauseBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            togglePause();
        });

        restartBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            manualRestart();
        });

        canvas.addEventListener('mousedown', handleStart);
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleStart(e); }, {passive: false});
        window.addEventListener('touchmove', (e) => { e.preventDefault(); handleMove(e); }, {passive: false});
        window.addEventListener('touchend', handleEnd);

        showStartScreen();
    </script>
</body>
</html>