<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>水果箱大賽</title>
    <style>
        body { 
            text-align: center; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            background: #fdf5e6; margin: 0; padding: 0; overflow: hidden; touch-action: none; 
        }
        #game-container {
            width: 100vw; height: 100vh;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .stats { font-size: 20px; margin-bottom: 10px; color: #5d4037; font-weight: bold; min-height: 24px; }
        canvas { 
            background: white; border: 3px solid #8b4513; border-radius: 8px;
            max-width: 95vw; max-height: 80vh; touch-action: none; display: block;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- 只有在遊戲中才顯示分數和時間 -->
        <div class="stats" id="stats-bar" style="visibility: hidden;">
            分數: <span id="score">0</span> | 時間: <span id="timer">120</span>
        </div>
        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const timerEl = document.getElementById('timer');
        const statsBar = document.getElementById('stats-bar');
        
        const COLS = 17, ROWS = 10, CELL_SIZE = 50;
        canvas.width = COLS * CELL_SIZE;
        canvas.height = ROWS * CELL_SIZE;

        // 遊戲狀態：'start' (開始頁), 'playing' (遊戲中), 'gameover' (結算頁)
        let gameState = 'start'; 
        let grid = [], score = 0, timeLeft = 120;
        let isDragging = false, startX, startY, currentX, currentY;
        let timerInterval;
        let highScore = localStorage.getItem('fruitBoxHighScore') || 0;

        // 音效
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        function playSound(type) {
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain); gain.connect(audioCtx.destination);
                const now = audioCtx.currentTime;
                if (type === 'success') {
                    osc.frequency.setValueAtTime(800, now);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    osc.start(); osc.stop(now + 0.2);
                }
            } catch(e) {}
        }

        // 1. 顯示開始畫面
        function showStartScreen() {
            gameState = 'start';
            statsBar.style.visibility = 'hidden';
            draw();
        }

        // 2. 開始遊戲
        function startGame() {
            gameState = 'playing';
            statsBar.style.visibility = 'visible';
            score = 0;
            timeLeft = 120;
            scoreEl.innerText = score;
            timerEl.innerText = timeLeft;

            // 初始化格子
            for (let r = 0; r < ROWS; r++) {
                grid[r] = [];
                for (let c = 0; c < COLS; c++) {
                    grid[r][c] = { val: Math.floor(Math.random() * 9) + 1, cleared: false };
                }
            }

            if(timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if(timeLeft > 0) {
                    timeLeft--;
                    timerEl.innerText = timeLeft;
                } else {
                    endGame();
                }
                draw();
            }, 1000);
        }

        // 3. 遊戲結束
        function endGame() {
            gameState = 'gameover';
            clearInterval(timerInterval);
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('fruitBoxHighScore', highScore);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameState === 'start') {
                drawStartUI();
            } else if (gameState === 'playing' || gameState === 'gameover') {
                drawGrid();
                if (isDragging) drawSelection();
                if (gameState === 'gameover') drawResultUI();
            }
        }

        function drawStartUI() {
            // 背景裝飾
            ctx.fillStyle = "#fffae6";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 標題
            ctx.fillStyle = "#d32f2f";
            ctx.font = "bold 60px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("水果箱大賽", canvas.width/2, 180);

            // 玩法說明
            ctx.fillStyle = "#5d4037";
            ctx.font = "24px sans-serif";
            ctx.fillText("拖曳框選蘋果，數字總和等於 10 即可消除", canvas.width/2, 250);
            ctx.fillText("在 120 秒內挑戰最高分吧！", canvas.width/2, 290);

            // 開始按鈕
            ctx.fillStyle = "#43a047";
            ctx.fillRect(canvas.width/2 - 100, 350, 200, 60);
            ctx.fillStyle = "white";
            ctx.font = "bold 28px sans-serif";
            ctx.fillText("開始遊戲", canvas.width/2, 390);
        }

        function drawGrid() {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (!grid[r][c].cleared) {
                        ctx.fillStyle = "#ff4d4d"; ctx.beginPath();
                        ctx.arc(c * CELL_SIZE + 25, r * CELL_SIZE + 25, 18, 0, Math.PI * 2); ctx.fill();
                        ctx.fillStyle = "white"; ctx.font = "bold 20px Arial"; ctx.textAlign = "center";
                        ctx.fillText(grid[r][c].val, c * CELL_SIZE + 25, r * CELL_SIZE + 32);
                    }
                }
            }
        }

        function drawSelection() {
            let sum = calculateSum();
            ctx.strokeStyle = (sum === 10) ? "#4caf50" : "#2196f3";
            ctx.lineWidth = 3; 
            ctx.strokeRect(startX, startY, currentX - startX, currentY - startY);
            ctx.fillStyle = (sum === 10) ? "rgba(76,175,80,0.2)" : "rgba(33,150,243,0.1)";
            ctx.fillRect(startX, startY, currentX - startX, currentY - startY);
        }

        function drawResultUI() {
            ctx.fillStyle = "rgba(0,0,0,0.8)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = "white";
            ctx.fillRect(canvas.width/2 - 160, 100, 320, 280);
            
            ctx.fillStyle = "#333";
            ctx.font = "bold 32px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("遊戲結束", canvas.width/2, 160);
            
            ctx.font = "24px sans-serif";
            ctx.fillText("本次得分: " + score, canvas.width/2, 210);
            ctx.fillStyle = "#e67e22";
            ctx.fillText("最高紀錄: " + highScore, canvas.width/2, 250);

            // 再玩一次按鈕
            ctx.fillStyle = "#43a047";
            ctx.fillRect(canvas.width/2 - 80, 290, 160, 50);
            ctx.fillStyle = "white";
            ctx.font = "bold 22px sans-serif";
            ctx.fillText("再玩一次", canvas.width/2, 323);
        }

        function calculateSum() {
            let x1 = Math.min(startX, currentX), x2 = Math.max(startX, currentX);
            let y1 = Math.min(startY, currentY), y2 = Math.max(startY, currentY);
            let sum = 0;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    let cx = c * CELL_SIZE + 25, cy = r * CELL_SIZE + 25;
                    if (!grid[r][c].cleared && cx > x1 && cx < x2 && cy > y1 && cy < y2) sum += grid[r][c].val;
                }
            }
            return sum;
        }

        // --- 輸入控制 ---
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
        }

        function handleStart(e) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const pos = getPos(e);

            if (gameState === 'start') {
                // 檢查是否點擊「開始遊戲」按鈕
                if (pos.x > canvas.width/2 - 100 && pos.x < canvas.width/2 + 100 &&
                    pos.y > 350 && pos.y < 410) {
                    startGame();
                }
            } else if (gameState === 'gameover') {
                // 檢查是否點擊「再玩一次」按鈕
                if (pos.x > canvas.width/2 - 80 && pos.x < canvas.width/2 + 80 &&
                    pos.y > 290 && pos.y < 340) {
                    showStartScreen(); // 回到開始畫面
                }
            } else if (gameState === 'playing') {
                isDragging = true;
                startX = pos.x; startY = pos.y;
                currentX = pos.x; currentY = pos.y;
            }
        }

        function handleMove(e) {
            if (!isDragging || gameState !== 'playing') return;
            const pos = getPos(e);
            currentX = pos.x; currentY = pos.y;
            draw();
        }

        function handleEnd() {
            if (!isDragging) return;
            isDragging = false;
            
            let x1 = Math.min(startX, currentX), x2 = Math.max(startX, currentX);
            let y1 = Math.min(startY, currentY), y2 = Math.max(startY, currentY);
            let selected = [], sum = 0;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    let cx = c * CELL_SIZE + 25, cy = r * CELL_SIZE + 25;
                    if (!grid[r][c].cleared && cx > x1 && cx < x2 && cy > y1 && cy < y2) {
                        selected.push({r, c});
                        sum += grid[r][c].val;
                    }
                }
            }
            if (sum === 10) {
                selected.forEach(p => grid[p.r][p.c].cleared = true);
                score += selected.length;
                scoreEl.innerText = score;
                playSound('success');
            }
            draw();
        }

        // 事件監聽
        canvas.addEventListener('mousedown', handleStart);
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('mouseup', handleEnd);
        
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleStart(e); }, {passive: false});
        window.addEventListener('touchmove', (e) => { e.preventDefault(); handleMove(e); }, {passive: false});
        window.addEventListener('touchend', handleEnd);

        // 初始化顯示
        showStartScreen();
    </script>
</body>
</html>